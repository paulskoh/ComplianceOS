import { Injectable } from '@nestjs/common';
import * as PDFDocument from 'pdfkit';
import * as archiver from 'archiver';
import { Readable } from 'stream';
import { S3Service } from '../s3/s3.service';

@Injectable()
export class PackGeneratorService {
  constructor(private s3: S3Service) {}

  async generateSummaryPdf(data: any): Promise<Buffer> {
    return new Promise((resolve, reject) => {
      const doc = new PDFDocument({ margin: 50 });
      const chunks: Buffer[] = [];

      doc.on('data', (chunk) => chunks.push(chunk));
      doc.on('end', () => resolve(Buffer.concat(chunks)));
      doc.on('error', reject);

      // Header
      doc.fontSize(24).text('ComplianceOS Inspection Pack', { align: 'center' });
      doc.moveDown();
      doc.fontSize(16).text(data.packName, { align: 'center' });
      doc.moveDown(2);

      // Metadata
      doc.fontSize(12);
      doc.text(`Domain: ${data.domain}`);
      doc.text(`Date Range: ${data.dateRange.start} to ${data.dateRange.end}`);
      doc.text(`Generated: ${new Date().toISOString()}`);
      doc.moveDown(2);

      // Executive Summary
      doc.fontSize(18).text('Executive Summary');
      doc.moveDown();
      doc.fontSize(12);
      doc.text(`Total Obligations: ${data.obligations.length}`);
      doc.text(`Total Controls: ${data.controls.length}`);
      doc.text(`Evidence Artifacts: ${data.artifacts.length}`);
      doc.moveDown(2);

      // Obligations
      if (data.obligations.length > 0) {
        doc.fontSize(16).text('Obligations');
        doc.moveDown();
        doc.fontSize(10);
        data.obligations.forEach((obligation: any, index: number) => {
          doc.text(`${index + 1}. ${obligation.title}`);
          doc.fontSize(9).text(`   ${obligation.description}`, { width: 450 });
          doc.fontSize(10).moveDown(0.5);
        });
        doc.moveDown();
      }

      // Controls
      if (data.controls.length > 0) {
        doc.fontSize(16).text('Controls');
        doc.moveDown();
        doc.fontSize(10);
        data.controls.forEach((control: any, index: number) => {
          doc.text(`${index + 1}. ${control.name} (${control.type})`);
          doc.fontSize(9).text(`   ${control.description}`, { width: 450 });
          doc.fontSize(10).moveDown(0.5);
        });
      }

      // Footer
      doc.fontSize(8).text(
        'This document was generated by ComplianceOS',
        50,
        doc.page.height - 50,
        { align: 'center' },
      );

      doc.end();
    });
  }

  generateManifest(data: any) {
    return {
      packId: data.packId,
      generatedAt: new Date().toISOString(),
      obligations: data.obligations.map((o: any) => ({
        id: o.id,
        title: o.title,
        domain: o.domain,
      })),
      controls: data.controls.map((c: any) => ({
        id: c.id,
        name: c.name,
        type: c.type,
      })),
      artifacts: data.artifacts.map((a: any) => ({
        id: a.id,
        name: a.name,
        type: a.type,
        hash: a.hash,
        source: a.source,
        accessClassification: a.accessClassification,
        createdAt: a.createdAt,
        fileName: a.binary?.fileName,
        fileSize: a.binary?.fileSize,
      })),
    };
  }

  async generateZipBundle(artifacts: any[]): Promise<Readable> {
    const archive = archiver('zip', { zlib: { level: 9 } });

    // Add README
    archive.append(
      'This ZIP contains evidence artifacts for the inspection pack.\n\n' +
        'Generated by ComplianceOS\n' +
        `Generated at: ${new Date().toISOString()}\n`,
      { name: 'README.txt' },
    );

    // In a real implementation, download files from S3 and add to ZIP
    // For now, we'll add placeholder files
    for (const artifact of artifacts) {
      if (artifact.binary) {
        const placeholder = `Artifact: ${artifact.name}\nHash: ${artifact.hash}\nSource: ${artifact.source}`;
        archive.append(placeholder, {
          name: `artifacts/${artifact.binary.fileName}`,
        });
      }
    }

    archive.finalize();
    return archive;
  }
}
