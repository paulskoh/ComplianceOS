import { Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { ObligationDomain, EvidenceFrequency, RiskSeverity } from '@prisma/client';
import { EvaluationService } from '../evaluation/evaluation.service';

export interface GapItem {
  type: 'MISSING_EVIDENCE' | 'OUTDATED_EVIDENCE' | 'UNAPPROVED_EXCEPTION' | 'NO_CONTROL';
  severity: RiskSeverity;
  obligationId: string;
  obligationTitle: string;
  controlId?: string;
  controlName?: string;
  description: string;
  lastEvidenceDate?: Date;
  daysSinceEvidence?: number;
  expectedFrequency?: string;
}

@Injectable()
export class ReadinessService {
  constructor(
    private prisma: PrismaService,
    private evaluationService: EvaluationService,
  ) {}

  /**
   * Calculate real readiness score with gap analysis
   * Now unified with EvaluationService - single source of truth
   */
  async getScore(tenantId: string) {
    // Run full evaluation using the unified evaluation engine
    const evaluation = await this.evaluationService.runFullEvaluation(tenantId);

    // Convert evaluation results to gaps for backward compatibility
    const gaps = await this.evaluationResultsToGaps(tenantId, evaluation);

    // Calculate score based on gaps
    const score = this.calculateScore(gaps);

    // Get domain breakdown
    const domainScores = await this.getDomainScores(tenantId, gaps);

    // Get summary stats
    const stats = await this.getStats(tenantId);

    return {
      overallScore: score.overall,
      readinessLevel: score.level,
      gaps: gaps.length,
      criticalGaps: gaps.filter((g) => g.severity === 'CRITICAL').length,
      highGaps: gaps.filter((g) => g.severity === 'HIGH').length,
      mediumGaps: gaps.filter((g) => g.severity === 'MEDIUM').length,
      lowGaps: gaps.filter((g) => g.severity === 'LOW').length,
      domainScores,
      gapDetails: gaps.slice(0, 20), // Top 20 most critical gaps
      stats,
    };
  }

  /**
   * Convert evaluation results to gaps for backward compatibility
   */
  private async evaluationResultsToGaps(tenantId: string, evaluation: any): Promise<GapItem[]> {
    const gaps: GapItem[] = [];

    // Get all obligations with their metadata for gap descriptions
    const obligations = await this.prisma.obligation.findMany({
      where: { tenantId, isActive: true },
      include: {
        controls: {
          include: {
            control: true,
          },
        },
      },
    });

    // Create obligation and control lookups
    const obligationMap = new Map(obligations.map(o => [o.id, o]));
    const controlMap = new Map<string, any>();
    for (const obl of obligations) {
      for (const { control } of obl.controls) {
        controlMap.set(control.id, { control, obligation: obl });
      }
    }

    // Convert risks generated by EvaluationService to gaps
    for (const risk of evaluation.risks) {
      const obligationId = risk.obligationCode; // This is actually the ID in our case
      const obligation = obligationMap.get(obligationId);

      if (!obligation) continue;

      const controlData = controlMap.get(risk.controlCode); // This is actually the ID

      let gapType: GapItem['type'];
      let severity: RiskSeverity = risk.severity as RiskSeverity;

      // Map risk types to gap types
      switch (risk.riskType) {
        case 'MISSING_EVIDENCE':
          gapType = 'MISSING_EVIDENCE';
          break;
        case 'STALE_EVIDENCE':
          gapType = 'OUTDATED_EVIDENCE';
          break;
        case 'FAILED_CONTROL':
          gapType = 'MISSING_EVIDENCE';
          break;
        default:
          gapType = 'MISSING_EVIDENCE';
      }

      gaps.push({
        type: gapType,
        severity,
        obligationId: obligation.id,
        obligationTitle: obligation.titleKo || obligation.title,
        controlId: controlData?.control.id,
        controlName: controlData?.control.name,
        description: risk.description,
      });
    }

    // Check for obligations with no controls
    for (const obligation of obligations) {
      if (obligation.controls.length === 0) {
        gaps.push({
          type: 'NO_CONTROL',
          severity: 'HIGH',
          obligationId: obligation.id,
          obligationTitle: obligation.titleKo || obligation.title,
          description: `"${obligation.titleKo || obligation.title}" 의무에 대한 통제 항목이 없습니다. 통제를 생성하세요.`,
        });
      }
    }

    // Check for unapproved exceptions
    const unapprovedExceptions = await this.prisma.exceptionRequest.findMany({
      where: {
        tenantId,
        status: 'PENDING',
        expiresAt: { gt: new Date() },
      },
      include: {
        control: {
          include: {
            obligations: {
              include: {
                obligation: true,
              },
            },
          },
        },
      },
    });

    for (const exception of unapprovedExceptions) {
      const obligation = exception.control.obligations[0]?.obligation;
      gaps.push({
        type: 'UNAPPROVED_EXCEPTION',
        severity: 'MEDIUM',
        obligationId: obligation?.id || '',
        obligationTitle: obligation?.titleKo || 'Unknown',
        controlId: exception.controlId,
        controlName: exception.control?.name,
        description: `미승인 예외 요청: ${exception.reason}`,
      });
    }

    // Sort by severity
    const severityOrder = { CRITICAL: 0, HIGH: 1, MEDIUM: 2, LOW: 3 };
    gaps.sort((a, b) => severityOrder[a.severity] - severityOrder[b.severity]);

    return gaps;
  }

  /**
   * Calculate readiness score (0-100) using weighted scoring
   * Based on obligation severity weights and evidence requirement completion
   */
  private calculateScore(gaps: GapItem[]): { overall: number; level: string } {
    let baseScore = 100;

    // Deduct points based on gap severity
    for (const gap of gaps) {
      switch (gap.severity) {
        case 'CRITICAL':
          baseScore -= 15;
          break;
        case 'HIGH':
          baseScore -= 8;
          break;
        case 'MEDIUM':
          baseScore -= 3;
          break;
        case 'LOW':
          baseScore -= 1;
          break;
      }
    }

    const score = Math.max(0, Math.min(100, baseScore));

    // Determine readiness level
    let level: string;
    if (score >= 90) level = 'EXCELLENT';
    else if (score >= 75) level = 'GOOD';
    else if (score >= 60) level = 'FAIR';
    else if (score >= 40) level = 'POOR';
    else level = 'CRITICAL';

    return { overall: score, level };
  }

  /**
   * Calculate weighted readiness score (v2)
   * Weights: CRITICAL=20%, HIGH=15%, MEDIUM=10%, LOW=5%
   */
  async calculateWeightedScore(tenantId: string): Promise<{
    overallScore: number
    level: string
    breakdown: {
      totalPossiblePoints: number
      earnedPoints: number
      criticalRequirements: { total: number; completed: number; percentage: number }
      highRequirements: { total: number; completed: number; percentage: number }
      mediumRequirements: { total: number; completed: number; percentage: number }
      lowRequirements: { total: number; completed: number; percentage: number }
    }
    topRisks: Array<{
      obligationId: string
      obligationTitle: string
      severity: RiskSeverity
      missingRequirements: number
      impact: number
    }>
  }> {
    // Weight mapping
    const weights = {
      CRITICAL: 20,
      HIGH: 15,
      MEDIUM: 10,
      LOW: 5,
    };

    // Get all obligations with their evidence requirements
    const obligations = await this.prisma.obligation.findMany({
      where: { tenantId, isActive: true },
      include: {
        controls: {
          include: {
            control: {
              include: {
                evidenceRequirements: {
                  include: {
                    artifacts: {
                      where: {
                        status: { in: ['ANALYZED', 'APPROVED'] },
                      },
                      orderBy: { createdAt: 'desc' },
                      take: 1,
                    },
                  },
                },
              },
            },
          },
        },
      },
    });

    let totalPossiblePoints = 0;
    let earnedPoints = 0;

    const breakdown = {
      CRITICAL: { total: 0, completed: 0 },
      HIGH: { total: 0, completed: 0 },
      MEDIUM: { total: 0, completed: 0 },
      LOW: { total: 0, completed: 0 },
    };

    const obligationRisks: Map<string, { missing: number; weight: number; title: string }> = new Map();

    // Calculate scores per obligation
    for (const obligation of obligations) {
      const severity = obligation.severity as RiskSeverity;
      const weight = weights[severity] || 5;

      // Get all evidence requirements for this obligation
      const evidenceRequirements = obligation.controls.flatMap(co =>
        co.control.evidenceRequirements || [],
      );

      if (evidenceRequirements.length === 0) continue;

      const totalRequirements = evidenceRequirements.length;
      const completedRequirements = evidenceRequirements.filter(
        req => req.artifacts && req.artifacts.length > 0,
      ).length;

      // Calculate points for this obligation
      const obligationPoints = weight;
      const completionRate = completedRequirements / totalRequirements;
      const obligationEarned = obligationPoints * completionRate;

      totalPossiblePoints += obligationPoints;
      earnedPoints += obligationEarned;

      // Track breakdown by severity
      breakdown[severity].total += totalRequirements;
      breakdown[severity].completed += completedRequirements;

      // Track risks (obligations with missing requirements)
      if (completedRequirements < totalRequirements) {
        obligationRisks.set(obligation.id, {
          missing: totalRequirements - completedRequirements,
          weight,
          title: obligation.titleKo || obligation.title,
        });
      }
    }

    // Calculate overall score (0-100)
    const overallScore = totalPossiblePoints > 0
      ? Math.round((earnedPoints / totalPossiblePoints) * 100)
      : 0;

    // Determine level
    let level: string;
    if (overallScore >= 90) level = 'EXCELLENT';
    else if (overallScore >= 75) level = 'GOOD';
    else if (overallScore >= 60) level = 'FAIR';
    else if (overallScore >= 40) level = 'POOR';
    else level = 'CRITICAL';

    // Identify top 3 risks (highest impact)
    const topRisks = Array.from(obligationRisks.entries())
      .map(([id, data]) => {
        const obligation = obligations.find(o => o.id === id)!;
        return {
          obligationId: id,
          obligationTitle: data.title,
          severity: obligation.severity as RiskSeverity,
          missingRequirements: data.missing,
          impact: data.missing * data.weight,
        };
      })
      .sort((a, b) => b.impact - a.impact)
      .slice(0, 3);

    return {
      overallScore,
      level,
      breakdown: {
        totalPossiblePoints,
        earnedPoints,
        criticalRequirements: {
          total: breakdown.CRITICAL.total,
          completed: breakdown.CRITICAL.completed,
          percentage: breakdown.CRITICAL.total > 0
            ? Math.round((breakdown.CRITICAL.completed / breakdown.CRITICAL.total) * 100)
            : 0,
        },
        highRequirements: {
          total: breakdown.HIGH.total,
          completed: breakdown.HIGH.completed,
          percentage: breakdown.HIGH.total > 0
            ? Math.round((breakdown.HIGH.completed / breakdown.HIGH.total) * 100)
            : 0,
        },
        mediumRequirements: {
          total: breakdown.MEDIUM.total,
          completed: breakdown.MEDIUM.completed,
          percentage: breakdown.MEDIUM.total > 0
            ? Math.round((breakdown.MEDIUM.completed / breakdown.MEDIUM.total) * 100)
            : 0,
        },
        lowRequirements: {
          total: breakdown.LOW.total,
          completed: breakdown.LOW.completed,
          percentage: breakdown.LOW.total > 0
            ? Math.round((breakdown.LOW.completed / breakdown.LOW.total) * 100)
            : 0,
        },
      },
      topRisks,
    };
  }

  /**
   * Get domain-specific scores
   */
  private async getDomainScores(tenantId: string, allGaps: GapItem[]) {
    const domains = Object.values(ObligationDomain);

    const scores = await Promise.all(
      domains.map(async (domain) => {
        const obligations = await this.prisma.obligation.count({
          where: { tenantId, domain, isActive: true },
        });

        if (obligations === 0) {
          return { domain, score: 100, obligations: 0, gaps: 0 };
        }

        // Get obligation IDs for this domain
        const obligationIds = await this.prisma.obligation.findMany({
          where: { tenantId, domain, isActive: true },
          select: { id: true },
        });

        const ids = obligationIds.map((o) => o.id);
        const domainGaps = allGaps.filter((g) => ids.includes(g.obligationId));

        // Calculate score
        let score = 100;
        for (const gap of domainGaps) {
          switch (gap.severity) {
            case 'CRITICAL':
              score -= 15;
              break;
            case 'HIGH':
              score -= 8;
              break;
            case 'MEDIUM':
              score -= 3;
              break;
            case 'LOW':
              score -= 1;
              break;
          }
        }

        return {
          domain,
          score: Math.max(0, Math.min(100, score)),
          obligations,
          gaps: domainGaps.length,
        };
      }),
    );

    return scores.filter((s) => s.obligations > 0);
  }

  /**
   * Get summary statistics
   */
  private async getStats(tenantId: string) {
    const [
      totalObligations,
      totalControls,
      totalArtifacts,
      totalRisks,
      openRisks,
      overdueRisks,
    ] = await Promise.all([
      this.prisma.obligation.count({ where: { tenantId, isActive: true } }),
      this.prisma.control.count({ where: { tenantId, isActive: true } }),
      this.prisma.artifact.count({ where: { tenantId, isDeleted: false } }),
      this.prisma.riskItem.count({ where: { tenantId } }),
      this.prisma.riskItem.count({ where: { tenantId, status: 'OPEN' } }),
      this.prisma.riskItem.count({
        where: { tenantId, status: 'OPEN', dueDate: { lt: new Date() } },
      }),
    ]);

    return {
      totalObligations,
      totalControls,
      totalArtifacts,
      totalRisks,
      openRisks,
      overdueRisks,
    };
  }

  /**
   * Helper: Get severity based on freshness window in days
   */
  private getSeverityByFreshnessDays(days: number): RiskSeverity {
    if (days <= 3) return 'CRITICAL'; // Daily/continuous
    if (days <= 35) return 'HIGH'; // Weekly/monthly
    if (days <= 100) return 'MEDIUM'; // Quarterly
    return 'LOW'; // Annual or longer
  }

  /**
   * Helper: Get days since date
   */
  private getDaysSince(date: Date): number {
    const now = new Date();
    const diff = now.getTime() - date.getTime();
    return Math.floor(diff / (1000 * 60 * 60 * 24));
  }

  /**
   * Helper: Calculate due date based on severity
   */
  private calculateDueDate(severity: RiskSeverity): Date {
    const days = {
      CRITICAL: 3,
      HIGH: 7,
      MEDIUM: 14,
      LOW: 30,
    };

    const dueDate = new Date();
    dueDate.setDate(dueDate.getDate() + days[severity]);
    return dueDate;
  }

  /**
   * Get detailed gap report
   * Now unified with EvaluationService
   */
  async getGapReport(tenantId: string) {
    // Run full evaluation
    const evaluation = await this.evaluationService.runFullEvaluation(tenantId);

    // Convert to gaps
    const gaps = await this.evaluationResultsToGaps(tenantId, evaluation);

    return {
      total: gaps.length,
      bySeverity: {
        critical: gaps.filter((g) => g.severity === 'CRITICAL').length,
        high: gaps.filter((g) => g.severity === 'HIGH').length,
        medium: gaps.filter((g) => g.severity === 'MEDIUM').length,
        low: gaps.filter((g) => g.severity === 'LOW').length,
      },
      byType: {
        missingEvidence: gaps.filter((g) => g.type === 'MISSING_EVIDENCE').length,
        outdatedEvidence: gaps.filter((g) => g.type === 'OUTDATED_EVIDENCE').length,
        noControl: gaps.filter((g) => g.type === 'NO_CONTROL').length,
        unapprovedException: gaps.filter((g) => g.type === 'UNAPPROVED_EXCEPTION')
          .length,
      },
      gaps: gaps.map((g) => ({
        ...g,
        actionRequired: this.getActionForGap(g),
      })),
    };
  }

  /**
   * Get recommended action for a gap
   */
  private getActionForGap(gap: GapItem): string {
    switch (gap.type) {
      case 'MISSING_EVIDENCE':
        return `"${gap.description.split('"')[1]}" 증빙을 업로드하세요.`;
      case 'OUTDATED_EVIDENCE':
        return `최신 증빙을 업로드하세요. (${gap.expectedFrequency} 주기 필요)`;
      case 'NO_CONTROL':
        return '통제 항목을 생성하고 증빙 요구사항을 정의하세요.';
      case 'UNAPPROVED_EXCEPTION':
        return '예외 요청을 검토하고 승인/거부하세요.';
      default:
        return '조치가 필요합니다.';
    }
  }

  /**
   * Get readiness score V2 for CEO demo
   * Returns obligation-wise breakdown with weighted scoring and top 3 risks
   */
  async getScoreV2(tenantId: string) {
    // Get all obligations with evidence requirements and artifacts
    const obligations = await this.prisma.obligation.findMany({
      where: { tenantId, isActive: true },
      include: {
        controls: {
          include: {
            control: {
              include: {
                evidenceRequirements: {
                  include: {
                    artifactLinks: {
                      include: {
                        artifact: true,
                      },
                      orderBy: {
                        artifact: { uploadedAt: 'desc' },
                      },
                      take: 1,
                    },
                  },
                },
              },
            },
          },
        },
      },
      orderBy: { severity: 'desc' },
    });

    // Weight mapping based on severity
    const severityWeights = {
      HIGH: 40,
      MEDIUM: 35,
      LOW: 25,
    };

    let totalObligations = obligations.length;
    let totalEvidence = 0;
    let verifiedEvidence = 0;
    const obligationScores: any[] = [];
    const allRisks: any[] = [];

    let weightedSum = 0;
    let totalWeight = 0;

    for (const obligation of obligations) {
      const evidenceRequirements = obligation.controls.flatMap(
        (oc) => oc.control.evidenceRequirements,
      );

      if (evidenceRequirements.length === 0) continue;

      const evidenceCount = evidenceRequirements.length;
      totalEvidence += evidenceCount;

      let verifiedCount = 0;
      let missingCount = 0;
      let flaggedCount = 0;

      for (const req of evidenceRequirements) {
        const latestArtifactLink = req.artifactLinks[0];
        const latestArtifact = latestArtifactLink?.artifact;

        if (!latestArtifact) {
          missingCount++;
          allRisks.push({
            obligationId: obligation.id,
            obligationTitleKo: obligation.titleKo,
            evidenceRequirementId: req.id,
            evidenceRequirementTitleKo: req.name,
            severity: obligation.severity,
            reason: '증빙 자료가 아직 제출되지 않았습니다',
            impact: severityWeights[obligation.severity] || 25,
          });
        } else if (latestArtifact.isApproved) {
          verifiedCount++;
          verifiedEvidence++;
        } else if (latestArtifact.status === 'READY') {
          // Uploaded but not yet approved - count as in progress (not verified, not missing)
        }
      }

      // Calculate obligation score (0-100)
      const completionRate = evidenceCount > 0 ? verifiedCount / evidenceCount : 0;
      const obligationScore = Math.round(completionRate * 100);

      // Calculate weight percentage
      const weight = severityWeights[obligation.severity] || 25;
      totalWeight += weight;
      weightedSum += obligationScore * (weight / 100);

      obligationScores.push({
        obligationId: obligation.id,
        obligationTitleKo: obligation.titleKo,
        severity: obligation.severity,
        weightPercent: weight,
        evidenceCount,
        verifiedCount,
        missingCount,
        flaggedCount,
        score: obligationScore,
      });
    }

    // Calculate overall weighted score
    const overallScore = totalWeight > 0 ? Math.round(weightedSum) : 0;

    // Get top 3 risks by impact
    const topRisks = allRisks
      .sort((a, b) => b.impact - a.impact)
      .slice(0, 3)
      .map(({ impact, ...rest }) => rest);

    return {
      overallScore,
      totalObligations,
      totalEvidence,
      verifiedEvidence,
      obligationScores,
      topRisks,
    };
  }
}
